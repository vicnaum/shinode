{
  "runSettings": {
    "temperature": 1.0,
    "model": "models/gemini-3-pro-preview",
    "topP": 0.95,
    "topK": 64,
    "maxOutputTokens": 65536,
    "safetySettings": [{
      "category": "HARM_CATEGORY_HARASSMENT",
      "threshold": "OFF"
    }, {
      "category": "HARM_CATEGORY_HATE_SPEECH",
      "threshold": "OFF"
    }, {
      "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
      "threshold": "OFF"
    }, {
      "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
      "threshold": "OFF"
    }],
    "enableCodeExecution": false,
    "enableSearchAsATool": false,
    "enableBrowseAsATool": false,
    "enableAutoFunctionResponse": false,
    "thinkingBudget": -1,
    "outputResolution": "1K",
    "thinkingLevel": "THINKING_HIGH"
  },
  "systemInstruction": {
  },
  "chunkedPrompt": {
    "chunks": [{
      "driveDocument": {
        "id": "1mdLZE3szccIM736lG6dQ_JIgYR1NrmPC"
      },
      "role": "user",
      "tokenCount": 26115
    }, {
      "driveDocument": {
        "id": "1PIJzhZ7y-8vp2G0t3fBQxofyDWD_XtNk"
      },
      "role": "user",
      "tokenCount": 74740
    }, {
      "text": "I\u0027m having trouble with speed between the harness (which is faster - achieved 1200 blocks per second with 10-20 peers), and node (modernized and full rewrite) - achieving 400 blocks/s with 20 peers in benchmark mode (which should copy harness).\n\nI\u0027m trying to understand where is the bottleneck, or maybe we\u0027re doing something wrong in the pipeline. Could you analize both repos and tell me where to look at? And if you can - make a comparison between their ingestion/networking flows/pipelines?",
      "role": "user",
      "tokenCount": 121
    }, {
      "text": "**Assessing the Core Discrepancy**\n\nI\u0027m now zeroing in on the performance divergence. I\u0027ve pinpointed the objective: to dissect the block processing speed variations between the older \"harness\" design and the newer \"node\" architecture. The benchmark/probe mode is my primary lens for this investigation, and I am planning to analyze specific blocks per second.\n\n\n**Deciphering Code Structures**\n\nI\u0027m now diving into the code. I\u0027m focusing on the differences in networking and P2P implementation. The \"harness\" design seems raw, prioritizing concurrency. The new \"node\" version has a layered architecture, which might introduce some overhead. I\u0027m particularly interested in comparing how they handle `active_peers` and `peers_with_jobs`. I\u0027m starting by analyzing the legacy networking, and how it differs from the newer structure.\n\n\n**Investigating Peer Handling**\n\nI\u0027m presently focusing on how the \"harness\" and \"node\" designs handle peers and concurrency. The older system spawns a `tokio::spawn` loop per peer and tasks per batch request, pushing peers back into a channel immediately. The newer node uses an `Arc\u003cRwLock\u003e`-backed `PeerPool` and the `PeerWorkScheduler`. Although there is lock contention in `PeerPool`, in `run_benchmark_probe`, `NetworkPeer` objects (clones) are received via a channel (`ready_rx`). Both implementations use `request_headers_batch` and `request_receipt_counts`.\n\n\n**Comparing Work Pipelines**\n\nI\u0027m now comparing the work pipelines, focusing on batch handling. The older system has a queue lock and a complex escalation for failures. The new node uses the `PeerWorkScheduler`, also with a pending queue lock, as well as a channel for processed blocks to be added. The channel is then read by the sink to update stats. I\u0027m focusing on the differences in `next_batch_for_peer`, and how the data streams through these different architectures.\n\n\n**Differentiating Request Patterns**\n\nI\u0027m now investigating request patterns in the systems. It seems both handle headers and receipts, but there is now a clearer difference in how peers are managed. The \"harness\" design immediately re-uses peers, unlike the \"node,\" which might have some additional latency due to this. I\u0027m looking closer at the \"warmup\" period in the harness to see how this impacts performance.\n\n\n**Analyzing Data Allocations**\n\nI\u0027m now comparing memory allocations. I\u0027ve noted the \"Node\" version\u0027s `FetchProbeOutcome` allocates vectors, unlike the \"Harness,\" which updates stats directly. Also, the \"Node\" uses a channel for stats updates, whereas the harness updates shared state directly. I\u0027m focusing on the overhead of these allocations and the channel.\n\n\n\n**Evaluating Legacy Requesting**\n\nI\u0027m now comparing the \"harness\" and \"node\" receipt request handling. Both download full receipts, deserialize, count, and discard them, but the harness may involve less cloning. I\u0027m focusing on legacy implementations, and specifically, the handling of the receipts themselves, including the potential memory implications. I\u0027m looking at how the receipt sizes are determined and handled in each design.\n\n\n**Examining Task Execution**\n\nI\u0027m now examining task execution differences. Both systems use similar approaches for requesting headers. A key \"smell\" emerges with the \"Node,\" which creates a `ProbeRecord` for each block and sends it through a channel. This potentially creates a bottleneck. I\u0027m focusing on the performance implications.\n\n\n\n**Identifying Performance Bottlenecks**\n\nI\u0027m now focusing on the bottleneck of the \"Node\" design. The channel usage for `ProbeRecord` seems costly, especially at 1200 blocks per second, as it involves numerous channel sends, receives, and allocations compared to the \"Harness,\" which just increments counters or briefly locks mutexes. Also, both systems disable `tx_gossip` and have the same networking primitives. The peer count is also constant, at 20 peers. Finally, I\u0027m comparing the critical sections where blocks are processed.\n\n\n**Investigating Probe Overhead**\n\nI\u0027m now examining the \"Node\" design\u0027s `fetch_probe_batch`. It allocates and returns a `Vec` of `ProbeRecord` structs.  This introduces overhead, with `header_ms` and `receipts_ms` calculations, as well as the serialization overhead from `reth_eth_wire_types` structs, adding to potential performance bottlenecks. I am considering these costs in detail.\n\n\n**Comparing Data Structures**\n\nI\u0027m now comparing the data structures used for peer management in both the \"Harness\" and \"Node\" designs. I\u0027ve noted the similarities: both utilize `PeerRequestSender`. The \"Node\" employs a `NetworkPeer` struct which is `Clone`, in contrast to the \"Harness\"\u0027s `PeerHandle`, so I\u0027m investigating how the peer pool handles these cloned objects, and how they contribute to performance differences. I am re-examining `fetch_probe_batch` as a result.\n\n\n**Evaluating Logging Overhead**\n\nI\u0027m now focusing on logging differences between the two designs. The \"Harness\" logs JSON for every request start and end, using an atomic request ID. This overhead could significantly impact the benchmark. The \"Node\" version appears to have less logging in the hot path. I\u0027m measuring the impact of the \"Harness\" logging.\n\n\n**Investigating Refill Loop**\n\nI\u0027m now concentrating on the \"Refill\" loop, a major architectural difference. The \"Harness\" spawns one task that listens on `ready_rx`, whereas the \"Node\" uses a `JoinSet` in `run_benchmark_probe`. The critical question is whether `JoinSet` requires polling via `join_next` to clear finished tasks, or if it simply accumulates. This is highly relevant.\n\n\n**Assessing JoinSet Behavior**\n\nI\u0027ve just uncovered a significant difference in the \"Node\" design with the `JoinSet`. The `while fetch_tasks.join_next().await.is_some() {}` loop is outside the peer loop, so the `JoinSet` accumulates results. The critical difference appears to be that the peer is immediately placed back in the \"Harness,\" unlike the \"Node,\" where an explicit `ready_tx.send(peer)` is used.\n\n\n**Diagnosing JoinSet Problems**\n\nI\u0027ve just made a critical discovery. The Node design\u0027s `JoinSet`, while intended for concurrency, appears to be a major performance bottleneck. Unlike the Harness\u0027s `tokio::spawn`, the `JoinSet` accumulates results without ever being polled, causing memory issues. Because of this, large benchmarks result in large internal storage, leading to significant slowdowns. In the Harness, `tokio::spawn` provides instant cleanup, but not with this `JoinSet` implementation.\n\n\n**Evaluating Bottleneck Suspects**\n\nI\u0027m now focusing on specific bottlenecks. I\u0027ve noted a potentially serious issue within the \"Node\" design: the `JoinSet` accumulates results without periodic polling, causing exponential memory use. I\u0027m discarding the other hypotheses I\u0027ve considered. The `PeerPool` lock and `Arc\u003cMutex\u003e` stats are unlikely to be a problem. My primary focus is now on the `JoinSet` implementation.\n\n\n**Rethinking Concurrency Strategies**\n\nI\u0027m now re-evaluating the `JoinSet` in the \"Node\" design. It seems the lack of a polling mechanism leads to excessive memory use, accumulating a vast number of `JoinHandle` objects. This design choice, in contrast to the \"Harness\"\u0027s approach, is likely the key factor contributing to the performance differences. I am now considering how this could be alleviated.\n\n\n**Analyzing Channel Performance**\n\nI am now comparing the channel overhead in `processed_blocks_tx`. While I initially thought 1200 messages per second were trivial, I\u0027m focusing on the payload: `ProbeRecord`, which contains `FetchTiming` and `PeerId`. The harness uses a direct Mutex update. I\u0027m deep diving into `request_receipt_counts`, as opposed to legacy receipt handling.\n\n\n\n**Revisiting Receipt Handling**\n\nI am now focusing on the performance of the receipt retrieval process in both designs. I\u0027ve noted that both systems, when using the legacy implementation, call `request_receipt_counts_legacy`. Both implementations use `messages.try_send`, await an `oneshot` result, unwrap, and map to lengths. I\u0027m focusing on the payload to compare the underlying structures. I\u0027ll need to examine where these lengths are used.\n\n\n**Scrutinizing Peer Loop Logic**\n\nI am now closely examining the peer loop logic. I am focusing on subtle distinctions, particularly regarding `in_flight` tracking. The \"Harness\" uses atomic increments, whereas the \"Node\" relies on a `HashSet` protected by a mutex, which could cause contention. I am also seeking the origins of the request IDs.\n\n\n**Evaluating Logging Impacts**\n\nI\u0027m now investigating the specific impact of \"Harness\" logging, focusing on the serialization of JSON to a buffer channel within the hot path. The \"Node\" version avoids this, so it should be faster. Both implementations utilize identical logic within `next_batch_for_peer`, so I\u0027m focusing on the logging. I am now exploring the implications of the `batch.is_empty()` logic.\n\n\n**Comparing Peer Handling**\n\nI\u0027m now comparing the peer handling in the \"Harness\" and \"Node\" designs, and I\u0027ve noted a critical difference: empty batches result in the peer being dropped in the harness, whereas in the \"Node\" design, these peers are re-queued. I\u0027m focusing now on the implications of this approach.\n\n\n**Evaluating Tracing Strategies**\n\nI\u0027m now examining the impact of tracing overhead. I\u0027ve noted the \"Node\" uses `init_tracing`, while the \"Harness\" uses `tracing_subscriber` manually. I\u0027m focusing on the impact of `RUST_LOG` and its default settings, along with `tracing::warn` calls. I\u0027m also considering the `ProbeRecord` passing mechanism, which may introduce a channel bottleneck.\n\n\n\n**Analyzing Mutex Contention**\n\nI\u0027m now investigating the potential for Mutex contention, focusing on the `run_probe_sink` logic. I\u0027m specifically looking at the 3 mutexes acquired sequentially for timing vectors in the \"Node\" design, and comparing it to the single Mutex in the \"Harness.\" The sequential locking is not ideal, but probably not the primary cause of the slowdown. I am also considering missing block logic in both designs. I will now re-examine the receipt implementation.\n\n\n**Examining Data Transfer**\n\nI am now closely examining the data transfer patterns between peers and the request/response pipelines. In particular, I am observing that `request_receipt_counts`, as called in `fetch_probe_batch`, involves a considerable amount of data movement via the `peer.messages.try_send` mechanism, which may be a significant contributor to the performance differences. I will now examine legacy networking primitives, and where these sent values are consumed.\n\n\n**Investigating Concurrency Bottlenecks**\n\nI\u0027m now examining potential concurrency bottlenecks. I\u0027m focusing on the `request_headers_batch` calls to understand if these differ significantly. The \"Node\" version\u0027s `request_headers_batch` is being assessed now, as a potential contributor to the overall performance differences. I will now examine `request_receipt_counts`.\n\n\n**Investigating Slow Start Impact**\n\nI\u0027m now considering the impact of TCP slow start and peer dampening. The \"Harness\" waits 3 seconds, which the \"Node\" doesn\u0027t, so I am wondering if the node is hurt early on, which lowers the average block processing speed. I am also investigating metric reporting and block stats.\n\n\n\n**Rethinking Memory Management**\n\nI am now focusing on the memory management differences, especially related to the `ProbeStats` vectors. While the initial concern about vector resizing under a mutex lock seems less critical, the \"Node\" design\u0027s approach of accumulating data without clearing those vectors, unlike the \"Harness,\" remains concerning. However, for a standard 10s benchmark, the memory footprint seems negligible. It\u0027s time to re-examine the `JoinSet` implementation.\n\n\n\n**Prioritizing Remediation Strategies**\n\nI\u0027m now focusing on a plan to address the performance disparities. I\u0027ll prioritize fixing the `JoinSet` leak, since this seems to be the critical bottleneck. Next, I\u0027ll optimize the channel backpressure from the sink and reduce allocations in the hot path. Finally, I will ensure there is a warmup.\n\n\n\n**Refining Network Benchmarking**\n\nI\u0027m now narrowing my focus. I\u0027ve re-examined the receipt handling and allocation within `fetch_probe_batch`. Though I initially suspected the `Vec\u003cReceipt\u003e` structure, I see that both \"Harness\" and \"Node\" use identical types. I\u0027m no longer suspicious of that specific allocation. I\u0027m returning to the `JoinSet` as my primary area of focus.\n\n\\n\\n**Investigating Task Cleanup**\n\nI\u0027m now zeroing in on the behavior within `run_benchmark_probe`. Each call to `fetch_tasks.spawn` creates a new task that sends the peer back to the ready channel. The key is that the `JoinSet` accumulates both active and completed tasks. I\u0027m not seeing any mechanism for task cleanup or polling. This may lead to performance degradation.\n\n\\n\\n\n\n\n**Assessing Concurrency Issues**\n\nI\u0027m now investigating the potential for lock contention within the \"Node\" design\u0027s `PeerWorkScheduler`. The `requeue_failed` method acquires several mutexes including `pending`, `queued`, `attempts`, `failed`, and `in_flight`, which could introduce significant overhead compared to the \"Harness.\" I\u0027m now examining the impact of this multi-lock approach on performance.\n\n\n**Examining Concurrency Overheads**\n\nI\u0027m now focusing on the \"Node\" design\u0027s concurrent execution strategy within the peer loop. The architecture closely mirrors the \"Harness,\" except for the `JoinSet`. The `batch.is_empty()` logic introduces a 50ms delay per peer, which I will assess, because that will contribute to overhead.\n\n\n**Evaluating Idle Peer Handling**\n\nI\u0027m now examining how the \"Node\" design handles idle peers, and the 50ms delay. My focus shifts to understanding the impact of empty batches on performance, particularly in relation to the `request_receipt_counts` and `request_receipts_legacy` functions, which are structured identically across both designs. I will now examine how this is handled in practice.\n\n\n**Pinpointing Primary Bottlenecks**\n\nI\u0027ve determined that the key performance problems in the node architecture are the unbounded `JoinSet`, the absence of a warm-up period, and a potential channel bottleneck in the sink\u0027s stats update, which is likely saturated. The \u0027Node\u0027 design\u0027s sink architecture funnels all stats updates through a single channel and a single consumer task.\n\n\n\n**Re-evaluating Stats Handling**\n\nI\u0027m revisiting the performance of `record_probe` in the \"Harness\" now. I\u0027m reassessing whether the \"Node\"\u0027s channel-based stats updates are actually a bottleneck, because the mutex in the \"Harness\" is *highly* contended. I\u0027m focusing on the \"Harness\"\u0027s `record_probe` updates to `by_block`, `peer_stats`, and vector pushes, wondering if this mutex is the real serializing factor, even with fewer peers.\n\n\n**Refining Performance Comparisons**\n\nI am now focusing on refining the comparisons. I\u0027ve re-assessed the Node Sink and its lack of locking for the worker threads, which send data through a channel to a sink for writing. I\u0027m focusing on `PeerWorkScheduler`, and how its multiple locks potentially contribute to performance bottlenecks, even though both the harness and node have lock contention in `next_batch_for_peer`.\n\n\n**Revising Error Handling**\n\nI am now focusing on the error handling differences. I\u0027ve noted the \"Node\" design\u0027s use of `eyre` for backtrace capture, compared to the \"Harness\"\u0027s string errors. I\u0027m focusing on its impact on performance and the overhead of this approach, specifically the overhead on *every* error. It seems to be the main difference, but I am now re-examining other aspects. I\u0027ll need to re-examine the `run_benchmark_probe` function.\n\n\n**Comparing Header Sealing**\n\nI\u0027m now comparing the \"Harness\" and \"Node\" designs in more detail. Specifically, I\u0027m analyzing how `SealedHeader::seal_slow` is used. I\u0027ve noted that the hash is computed in the `probe_block_batch` routine of the harness, and similar processing happens in the node\u0027s `fetch_probe` routine.\n\n\n**Evaluating Header Sealing**\n\nI\u0027m now examining the \"Node\" design\u0027s header sealing. I\u0027ve pinpointed a potential performance hit: the repeated cloning of `Header` objects within `fetch_probe_batch` during the `SealedHeader::seal_slow` process. This is in contrast to the \"Harness,\" which moves the header, avoiding the clone. I\u0027m focusing on the cost of cloning bloom filters and other data.\n\n\n**Refining Performance Investigations**\n\nI\u0027m now revisiting the \"Harness\"\u0027s design. I\u0027ve noted it waits 3 seconds, which lets TCP window open. It makes 400 requests/sec. This differs from the \"Node\", which does not have this warm up period. Also, I\u0027m reconsidering the impact of the `JoinSet` as well as the overhead incurred by the `SealedHeader::seal_slow` clones. I\u0027ll need to run benchmarks.\n\n\n**Reassessing JSON Logging**\n\nI\u0027m now re-evaluating the impact of per-block JSON logging in the \"Harness\" design. While I was focused on cloning, I\u0027ve realized the \"Harness\" logs JSON for each block, and the Node does not. This is a likely bottleneck. I\u0027m focusing on the overhead of JSON serialization and file channel writes.\n\n\n**Revising Bottleneck Hypotheses**\n\nI\u0027m now revising my hypotheses. The `PeerId` size appears correct, so a 2KB allocation is likely not the major issue. While both systems requeue immediately, there are clearly other differences. I\u0027m focusing on the `fetch_tasks.spawn` behavior, and why `JoinSet` is slowing down the performance. I\u0027m re-assessing this.\n\n\n**Evaluating Stats Bottlenecks**\n\nI am now focusing on the stats bottleneck. I am investigating the \"Node\"\u0027s sink architecture, which channels all stats through a single thread and channel. The channel size of 2048 and the 32 batch size mean the sink might block. This leads to 1200 mutex acquisitions per second in the \"Node,\" and the vectors are never cleared. I\u0027m focusing on why this is the likely slowdown.\n\n\n**Revising Performance Suspects**\n\nI\u0027m now examining the memory growth in `ProbeStats` vectors within the \"Node\" design. While individual vector pushes appear inexpensive amortized, the cumulative effect of never clearing these vectors could become a bottleneck. The \"Harness\" clears the vectors, whereas the \"Node\" does not, and I\u0027m focusing on the implications of this approach to `push` operations.\n\n\n**Evaluating Performance Bottlenecks**\n\nI\u0027m now focusing on the key areas. I am now certain the `JoinSet` in the \"Node\" design is the source of a memory leak; it fails to poll, leading to the accumulation of finished tasks. I am also assessing memory usage in the stats update, and considering how data is handled there. Finally, I\u0027m focusing on the TCP warmup.\n\n\n\n**Revising Performance Conclusions**\n\nI\u0027ve just had a major breakthrough. I\u0027m now certain the \"Node\"\u0027s channel-based stats updates are a bottleneck because they never clear vectors, and I am reevaluating my conclusions. I now understand it\u0027s the `JoinSet` leak, the stats vector accumulation (which never clears) *and* the lack of a warmup that contribute to the performance problems.\n\n\n**Revising Timeout Investigation**\n\nI\u0027m now focusing on the timeout implementation within `request_headers_batch`. Both \"Node\" and \"Harness\" use `timeout(REQUEST_TIMEOUT, rx)`. With the identical code, I\u0027m now examining the execution context for differences in timeout behavior. I\u0027ll re-evaluate other aspects.\n\n\n**Refining Key Conclusions**\n\nI\u0027m now certain of the primary performance bottlenecks. I have confirmed a `JoinSet` leak, the absence of a TCP warmup, an overhead from header clones and a leak in stats vectors. I\u0027m focusing on crafting a response detailing these critical issues for remediation.\n\n\n",
      "role": "model",
      "tokenCount": 13454,
      "isThought": true,
      "parts": [{
        "text": "**Assessing the Core Discrepancy**\n\nI\u0027m now zeroing in on the performance divergence. I\u0027ve pinpointed the objective: to dissect the block processing speed variations between the older \"harness\" design and the newer \"node\" architecture. The benchmark/probe mode is my primary lens for this investigation, and I am planning to analyze specific blocks per second.\n\n\n",
        "thought": true
      }, {
        "text": "**Deciphering Code Structures**\n\nI\u0027m now diving into the code. I\u0027m focusing on the differences in networking and P2P implementation. The \"harness\" design seems raw, prioritizing concurrency. The new \"node\" version has a layered architecture, which might introduce some overhead. I\u0027m particularly interested in comparing how they handle `active_peers` and `peers_with_jobs`. I\u0027m starting by analyzing the legacy networking, and how it differs from the newer structure.\n\n\n",
        "thought": true
      }, {
        "text": "**Investigating Peer Handling**\n\nI\u0027m presently focusing on how the \"harness\" and \"node\" designs handle peers and concurrency. The older system spawns a `tokio::spawn` loop per peer and tasks per batch request, pushing peers back into a channel immediately. The newer node uses an `Arc\u003cRwLock\u003e`-backed `PeerPool` and the `PeerWorkScheduler`. Although there is lock contention in `PeerPool`, in `run_benchmark_probe`, `NetworkPeer` objects (clones) are received via a channel (`ready_rx`). Both implementations use `request_headers_batch` and `request_receipt_counts`.\n\n\n",
        "thought": true
      }, {
        "text": "**Comparing Work Pipelines**\n\nI\u0027m now comparing the work pipelines, focusing on batch handling. The older system has a queue lock and a complex escalation for failures. The new node uses the `PeerWorkScheduler`, also with a pending queue lock, as well as a channel for processed blocks to be added. The channel is then read by the sink to update stats. I\u0027m focusing on the differences in `next_batch_for_peer`, and how the data streams through these different architectures.\n\n\n",
        "thought": true
      }, {
        "text": "**Differentiating Request Patterns**\n\nI\u0027m now investigating request patterns in the systems. It seems both handle headers and receipts, but there is now a clearer difference in how peers are managed. The \"harness\" design immediately re-uses peers, unlike the \"node,\" which might have some additional latency due to this. I\u0027m looking closer at the \"warmup\" period in the harness to see how this impacts performance.\n\n\n",
        "thought": true
      }, {
        "text": "**Analyzing Data Allocations**\n\nI\u0027m now comparing memory allocations. I\u0027ve noted the \"Node\" version\u0027s `FetchProbeOutcome` allocates vectors, unlike the \"Harness,\" which updates stats directly. Also, the \"Node\" uses a channel for stats updates, whereas the harness updates shared state directly. I\u0027m focusing on the overhead of these allocations and the channel.\n\n\n\n",
        "thought": true
      }, {
        "text": "**Evaluating Legacy Requesting**\n\nI\u0027m now comparing the \"harness\" and \"node\" receipt request handling. Both download full receipts, deserialize, count, and discard them, but the harness may involve less cloning. I\u0027m focusing on legacy implementations, and specifically, the handling of the receipts themselves, including the potential memory implications. I\u0027m looking at how the receipt sizes are determined and handled in each design.\n\n\n",
        "thought": true
      }, {
        "text": "**Examining Task Execution**\n\nI\u0027m now examining task execution differences. Both systems use similar approaches for requesting headers. A key \"smell\" emerges with the \"Node,\" which creates a `ProbeRecord` for each block and sends it through a channel. This potentially creates a bottleneck. I\u0027m focusing on the performance implications.\n\n\n\n",
        "thought": true
      }, {
        "text": "**Identifying Performance Bottlenecks**\n\nI\u0027m now focusing on the bottleneck of the \"Node\" design. The channel usage for `ProbeRecord` seems costly, especially at 1200 blocks per second, as it involves numerous channel sends, receives, and allocations compared to the \"Harness,\" which just increments counters or briefly locks mutexes. Also, both systems disable `tx_gossip` and have the same networking primitives. The peer count is also constant, at 20 peers. Finally, I\u0027m comparing the critical sections where blocks are processed.\n\n\n",
        "thought": true
      }, {
        "text": "**Investigating Probe Overhead**\n\nI\u0027m now examining the \"Node\" design\u0027s `fetch_probe_batch`. It allocates and returns a `Vec` of `ProbeRecord` structs.  This introduces overhead, with `header_ms` and `receipts_ms` calculations, as well as the serialization overhead from `reth_eth_wire_types` structs, adding to potential performance bottlenecks. I am considering these costs in detail.\n\n\n",
        "thought": true
      }, {
        "text": "**Comparing Data Structures**\n\nI\u0027m now comparing the data structures used for peer management in both the \"Harness\" and \"Node\" designs. I\u0027ve noted the similarities: both utilize `PeerRequestSender`. The \"Node\" employs a `NetworkPeer` struct which is `Clone`, in contrast to the \"Harness\"\u0027s `PeerHandle`, so I\u0027m investigating how the peer pool handles these cloned objects, and how they contribute to performance differences. I am re-examining `fetch_probe_batch` as a result.\n\n\n",
        "thought": true
      }, {
        "text": "**Evaluating Logging Overhead**\n\nI\u0027m now focusing on logging differences between the two designs. The \"Harness\" logs JSON for every request start and end, using an atomic request ID. This overhead could significantly impact the benchmark. The \"Node\" version appears to have less logging in the hot path. I\u0027m measuring the impact of the \"Harness\" logging.\n\n\n",
        "thought": true
      }, {
        "text": "**Investigating Refill Loop**\n\nI\u0027m now concentrating on the \"Refill\" loop, a major architectural difference. The \"Harness\" spawns one task that listens on `ready_rx`, whereas the \"Node\" uses a `JoinSet` in `run_benchmark_probe`. The critical question is whether `JoinSet` requires polling via `join_next` to clear finished tasks, or if it simply accumulates. This is highly relevant.\n\n\n",
        "thought": true
      }, {
        "text": "**Assessing JoinSet Behavior**\n\nI\u0027ve just uncovered a significant difference in the \"Node\" design with the `JoinSet`. The `while fetch_tasks.join_next().await.is_some() {}` loop is outside the peer loop, so the `JoinSet` accumulates results. The critical difference appears to be that the peer is immediately placed back in the \"Harness,\" unlike the \"Node,\" where an explicit `ready_tx.send(peer)` is used.\n\n\n",
        "thought": true
      }, {
        "text": "**Diagnosing JoinSet Problems**\n\nI\u0027ve just made a critical discovery. The Node design\u0027s `JoinSet`, while intended for concurrency, appears to be a major performance bottleneck. Unlike the Harness\u0027s `tokio::spawn`, the `JoinSet` accumulates results without ever being polled, causing memory issues. Because of this, large benchmarks result in large internal storage, leading to significant slowdowns. In the Harness, `tokio::spawn` provides instant cleanup, but not with this `JoinSet` implementation.\n\n\n",
        "thought": true
      }, {
        "text": "**Evaluating Bottleneck Suspects**\n\nI\u0027m now focusing on specific bottlenecks. I\u0027ve noted a potentially serious issue within the \"Node\" design: the `JoinSet` accumulates results without periodic polling, causing exponential memory use. I\u0027m discarding the other hypotheses I\u0027ve considered. The `PeerPool` lock and `Arc\u003cMutex\u003e` stats are unlikely to be a problem. My primary focus is now on the `JoinSet` implementation.\n\n\n",
        "thought": true
      }, {
        "text": "**Rethinking Concurrency Strategies**\n\nI\u0027m now re-evaluating the `JoinSet` in the \"Node\" design. It seems the lack of a polling mechanism leads to excessive memory use, accumulating a vast number of `JoinHandle` objects. This design choice, in contrast to the \"Harness\"\u0027s approach, is likely the key factor contributing to the performance differences. I am now considering how this could be alleviated.\n\n\n",
        "thought": true
      }, {
        "text": "**Analyzing Channel Performance**\n\nI am now comparing the channel overhead in `processed_blocks_tx`. While I initially thought 1200 messages per second were trivial, I\u0027m focusing on the payload: `ProbeRecord`, which contains `FetchTiming` and `PeerId`. The harness uses a direct Mutex update. I\u0027m deep diving into `request_receipt_counts`, as opposed to legacy receipt handling.\n\n\n\n",
        "thought": true
      }, {
        "text": "**Revisiting Receipt Handling**\n\nI am now focusing on the performance of the receipt retrieval process in both designs. I\u0027ve noted that both systems, when using the legacy implementation, call `request_receipt_counts_legacy`. Both implementations use `messages.try_send`, await an `oneshot` result, unwrap, and map to lengths. I\u0027m focusing on the payload to compare the underlying structures. I\u0027ll need to examine where these lengths are used.\n\n\n",
        "thought": true
      }, {
        "text": "**Scrutinizing Peer Loop Logic**\n\nI am now closely examining the peer loop logic. I am focusing on subtle distinctions, particularly regarding `in_flight` tracking. The \"Harness\" uses atomic increments, whereas the \"Node\" relies on a `HashSet` protected by a mutex, which could cause contention. I am also seeking the origins of the request IDs.\n\n\n",
        "thought": true
      }, {
        "text": "**Evaluating Logging Impacts**\n\nI\u0027m now investigating the specific impact of \"Harness\" logging, focusing on the serialization of JSON to a buffer channel within the hot path. The \"Node\" version avoids this, so it should be faster. Both implementations utilize identical logic within `next_batch_for_peer`, so I\u0027m focusing on the logging. I am now exploring the implications of the `batch.is_empty()` logic.\n\n\n",
        "thought": true
      }, {
        "text": "**Comparing Peer Handling**\n\nI\u0027m now comparing the peer handling in the \"Harness\" and \"Node\" designs, and I\u0027ve noted a critical difference: empty batches result in the peer being dropped in the harness, whereas in the \"Node\" design, these peers are re-queued. I\u0027m focusing now on the implications of this approach.\n\n\n",
        "thought": true
      }, {
        "text": "**Evaluating Tracing Strategies**\n\nI\u0027m now examining the impact of tracing overhead. I\u0027ve noted the \"Node\" uses `init_tracing`, while the \"Harness\" uses `tracing_subscriber` manually. I\u0027m focusing on the impact of `RUST_LOG` and its default settings, along with `tracing::warn` calls. I\u0027m also considering the `ProbeRecord` passing mechanism, which may introduce a channel bottleneck.\n\n\n\n",
        "thought": true
      }, {
        "text": "**Analyzing Mutex Contention**\n\nI\u0027m now investigating the potential for Mutex contention, focusing on the `run_probe_sink` logic. I\u0027m specifically looking at the 3 mutexes acquired sequentially for timing vectors in the \"Node\" design, and comparing it to the single Mutex in the \"Harness.\" The sequential locking is not ideal, but probably not the primary cause of the slowdown. I am also considering missing block logic in both designs. I will now re-examine the receipt implementation.\n\n\n",
        "thought": true
      }, {
        "text": "**Examining Data Transfer**\n\nI am now closely examining the data transfer patterns between peers and the request/response pipelines. In particular, I am observing that `request_receipt_counts`, as called in `fetch_probe_batch`, involves a considerable amount of data movement via the `peer.messages.try_send` mechanism, which may be a significant contributor to the performance differences. I will now examine legacy networking primitives, and where these sent values are consumed.\n\n\n",
        "thought": true
      }, {
        "text": "**Investigating Concurrency Bottlenecks**\n\nI\u0027m now examining potential concurrency bottlenecks. I\u0027m focusing on the `request_headers_batch` calls to understand if these differ significantly. The \"Node\" version\u0027s `request_headers_batch` is being assessed now, as a potential contributor to the overall performance differences. I will now examine `request_receipt_counts`.\n\n\n",
        "thought": true
      }, {
        "text": "**Investigating Slow Start Impact**\n\nI\u0027m now considering the impact of TCP slow start and peer dampening. The \"Harness\" waits 3 seconds, which the \"Node\" doesn\u0027t, so I am wondering if the node is hurt early on, which lowers the average block processing speed. I am also investigating metric reporting and block stats.\n\n\n\n",
        "thought": true
      }, {
        "text": "**Rethinking Memory Management**\n\nI am now focusing on the memory management differences, especially related to the `ProbeStats` vectors. While the initial concern about vector resizing under a mutex lock seems less critical, the \"Node\" design\u0027s approach of accumulating data without clearing those vectors, unlike the \"Harness,\" remains concerning. However, for a standard 10s benchmark, the memory footprint seems negligible. It\u0027s time to re-examine the `JoinSet` implementation.\n\n\n\n",
        "thought": true
      }, {
        "text": "**Prioritizing Remediation Strategies**\n\nI\u0027m now focusing on a plan to address the performance disparities. I\u0027ll prioritize fixing the `JoinSet` leak, since this seems to be the critical bottleneck. Next, I\u0027ll optimize the channel backpressure from the sink and reduce allocations in the hot path. Finally, I will ensure there is a warmup.\n\n\n\n",
        "thought": true
      }, {
        "text": "**Refining Network Benchmarking**\n\nI\u0027m now narrowing my focus. I\u0027ve re-examined the receipt handling and allocation within `fetch_probe_batch`. Though I initially suspected the `Vec\u003cReceipt\u003e` structure, I see that both \"Harness\" and \"Node\" use identical types. I\u0027m no longer suspicious of that specific allocation. I\u0027m returning to the `JoinSet` as my primary area of focus.\n\n\\n\\n**Investigating Task Cleanup**\n\nI\u0027m now zeroing in on the behavior within `run_benchmark_probe`. Each call to `fetch_tasks.spawn` creates a new task that sends the peer back to the ready channel. The key is that the `JoinSet` accumulates both active and completed tasks. I\u0027m not seeing any mechanism for task cleanup or polling. This may lead to performance degradation.\n\n\\n\\n\n\n\n",
        "thought": true
      }, {
        "text": "**Assessing Concurrency Issues**\n\nI\u0027m now investigating the potential for lock contention within the \"Node\" design\u0027s `PeerWorkScheduler`. The `requeue_failed` method acquires several mutexes including `pending`, `queued`, `attempts`, `failed`, and `in_flight`, which could introduce significant overhead compared to the \"Harness.\" I\u0027m now examining the impact of this multi-lock approach on performance.\n\n\n",
        "thought": true
      }, {
        "text": "**Examining Concurrency Overheads**\n\nI\u0027m now focusing on the \"Node\" design\u0027s concurrent execution strategy within the peer loop. The architecture closely mirrors the \"Harness,\" except for the `JoinSet`. The `batch.is_empty()` logic introduces a 50ms delay per peer, which I will assess, because that will contribute to overhead.\n\n\n",
        "thought": true
      }, {
        "text": "**Evaluating Idle Peer Handling**\n\nI\u0027m now examining how the \"Node\" design handles idle peers, and the 50ms delay. My focus shifts to understanding the impact of empty batches on performance, particularly in relation to the `request_receipt_counts` and `request_receipts_legacy` functions, which are structured identically across both designs. I will now examine how this is handled in practice.\n\n\n",
        "thought": true
      }, {
        "text": "**Pinpointing Primary Bottlenecks**\n\nI\u0027ve determined that the key performance problems in the node architecture are the unbounded `JoinSet`, the absence of a warm-up period, and a potential channel bottleneck in the sink\u0027s stats update, which is likely saturated. The \u0027Node\u0027 design\u0027s sink architecture funnels all stats updates through a single channel and a single consumer task.\n\n\n\n",
        "thought": true
      }, {
        "text": "**Re-evaluating Stats Handling**\n\nI\u0027m revisiting the performance of `record_probe` in the \"Harness\" now. I\u0027m reassessing whether the \"Node\"\u0027s channel-based stats updates are actually a bottleneck, because the mutex in the \"Harness\" is *highly* contended. I\u0027m focusing on the \"Harness\"\u0027s `record_probe` updates to `by_block`, `peer_stats`, and vector pushes, wondering if this mutex is the real serializing factor, even with fewer peers.\n\n\n",
        "thought": true
      }, {
        "text": "**Refining Performance Comparisons**\n\nI am now focusing on refining the comparisons. I\u0027ve re-assessed the Node Sink and its lack of locking for the worker threads, which send data through a channel to a sink for writing. I\u0027m focusing on `PeerWorkScheduler`, and how its multiple locks potentially contribute to performance bottlenecks, even though both the harness and node have lock contention in `next_batch_for_peer`.\n\n\n",
        "thought": true
      }, {
        "text": "**Revising Error Handling**\n\nI am now focusing on the error handling differences. I\u0027ve noted the \"Node\" design\u0027s use of `eyre` for backtrace capture, compared to the \"Harness\"\u0027s string errors. I\u0027m focusing on its impact on performance and the overhead of this approach, specifically the overhead on *every* error. It seems to be the main difference, but I am now re-examining other aspects. I\u0027ll need to re-examine the `run_benchmark_probe` function.\n\n\n",
        "thought": true
      }, {
        "text": "**Comparing Header Sealing**\n\nI\u0027m now comparing the \"Harness\" and \"Node\" designs in more detail. Specifically, I\u0027m analyzing how `SealedHeader::seal_slow` is used. I\u0027ve noted that the hash is computed in the `probe_block_batch` routine of the harness, and similar processing happens in the node\u0027s `fetch_probe` routine.\n\n\n",
        "thought": true
      }, {
        "text": "**Evaluating Header Sealing**\n\nI\u0027m now examining the \"Node\" design\u0027s header sealing. I\u0027ve pinpointed a potential performance hit: the repeated cloning of `Header` objects within `fetch_probe_batch` during the `SealedHeader::seal_slow` process. This is in contrast to the \"Harness,\" which moves the header, avoiding the clone. I\u0027m focusing on the cost of cloning bloom filters and other data.\n\n\n",
        "thought": true
      }, {
        "text": "**Refining Performance Investigations**\n\nI\u0027m now revisiting the \"Harness\"\u0027s design. I\u0027ve noted it waits 3 seconds, which lets TCP window open. It makes 400 requests/sec. This differs from the \"Node\", which does not have this warm up period. Also, I\u0027m reconsidering the impact of the `JoinSet` as well as the overhead incurred by the `SealedHeader::seal_slow` clones. I\u0027ll need to run benchmarks.\n\n\n",
        "thought": true
      }, {
        "text": "**Reassessing JSON Logging**\n\nI\u0027m now re-evaluating the impact of per-block JSON logging in the \"Harness\" design. While I was focused on cloning, I\u0027ve realized the \"Harness\" logs JSON for each block, and the Node does not. This is a likely bottleneck. I\u0027m focusing on the overhead of JSON serialization and file channel writes.\n\n\n",
        "thought": true
      }, {
        "text": "**Revising Bottleneck Hypotheses**\n\nI\u0027m now revising my hypotheses. The `PeerId` size appears correct, so a 2KB allocation is likely not the major issue. While both systems requeue immediately, there are clearly other differences. I\u0027m focusing on the `fetch_tasks.spawn` behavior, and why `JoinSet` is slowing down the performance. I\u0027m re-assessing this.\n\n\n",
        "thought": true
      }, {
        "text": "**Evaluating Stats Bottlenecks**\n\nI am now focusing on the stats bottleneck. I am investigating the \"Node\"\u0027s sink architecture, which channels all stats through a single thread and channel. The channel size of 2048 and the 32 batch size mean the sink might block. This leads to 1200 mutex acquisitions per second in the \"Node,\" and the vectors are never cleared. I\u0027m focusing on why this is the likely slowdown.\n\n\n",
        "thought": true
      }, {
        "text": "**Revising Performance Suspects**\n\nI\u0027m now examining the memory growth in `ProbeStats` vectors within the \"Node\" design. While individual vector pushes appear inexpensive amortized, the cumulative effect of never clearing these vectors could become a bottleneck. The \"Harness\" clears the vectors, whereas the \"Node\" does not, and I\u0027m focusing on the implications of this approach to `push` operations.\n\n\n",
        "thought": true
      }, {
        "text": "**Evaluating Performance Bottlenecks**\n\nI\u0027m now focusing on the key areas. I am now certain the `JoinSet` in the \"Node\" design is the source of a memory leak; it fails to poll, leading to the accumulation of finished tasks. I am also assessing memory usage in the stats update, and considering how data is handled there. Finally, I\u0027m focusing on the TCP warmup.\n\n\n\n",
        "thought": true
      }, {
        "text": "**Revising Performance Conclusions**\n\nI\u0027ve just had a major breakthrough. I\u0027m now certain the \"Node\"\u0027s channel-based stats updates are a bottleneck because they never clear vectors, and I am reevaluating my conclusions. I now understand it\u0027s the `JoinSet` leak, the stats vector accumulation (which never clears) *and* the lack of a warmup that contribute to the performance problems.\n\n\n",
        "thought": true
      }, {
        "text": "**Revising Timeout Investigation**\n\nI\u0027m now focusing on the timeout implementation within `request_headers_batch`. Both \"Node\" and \"Harness\" use `timeout(REQUEST_TIMEOUT, rx)`. With the identical code, I\u0027m now examining the execution context for differences in timeout behavior. I\u0027ll re-evaluate other aspects.\n\n\n",
        "thought": true
      }, {
        "text": "**Refining Key Conclusions**\n\nI\u0027m now certain of the primary performance bottlenecks. I have confirmed a `JoinSet` leak, the absence of a TCP warmup, an overhead from header clones and a leak in stats vectors. I\u0027m focusing on crafting a response detailing these critical issues for remediation.\n\n\n",
        "thought": true
      }]
    }, {
      "text": "This is a classic case of \"death by a thousand cuts\" where a clean, layered architecture introduces several small overheads that accumulate, along with a few specific implementation details that are functionally correct but performantly suboptimal compared to the raw \"harness\".\n\nHere is an analysis of the bottlenecks in the Node implementation compared to the Harness, ordered by impact.\n\n### 1. The \"JoinSet\" Leak (Major Resource/Runtime Overhead)\n\nIn the Harness, tasks are spawned using `tokio::spawn` and forgotten (detached). In the Node, you use a `JoinSet` but **you never poll it** inside the hot loop.\n\n**Location:** `sync/historical/mod.rs` (lines 130-134)\n\n```rust\n// Node: sync/historical/mod.rs\nlet mut fetch_tasks: JoinSet\u003c()\u003e \u003d JoinSet::new();\nwhile let Some(peer) \u003d ready_rx.recv().await {\n    // ...\n    fetch_tasks.spawn(async move { ... });\n}\n// join_next is only called AFTER the loop finishes\n```\n\n**The Problem:**\nA `tokio::task::JoinSet` accumulates the results of finished tasks until you call `join_next()`. By not polling this inside the `while` loop, the Node accumulates a handle and a result for **every single batch processed** since the start of the run.\n*   **Impact:** Memory usage grows linearly. The runtime has to manage a massive list of finished task handles. This puts pressure on the allocator and the Tokio runtime scheduler.\n*   **Fix:** Poll the set inside the loop or switch to `tokio::spawn` if you don\u0027t need to track the tasks explicitly during the run.\n\n**Proposed Fix:**\n```rust\nwhile let Some(peer) \u003d ready_rx.recv().await {\n    // Clean up finished tasks to free memory/handles\n    while fetch_tasks.try_join_next().is_some() {} \n    \n    // ... existing logic ...\n    fetch_tasks.spawn(...)\n}\n```\n\n### 2. Lack of P2P Warmup (Networking Stability)\n\nThe Harness has a specific \"Warmup\" period. The Node connects and immediately blasts peers with requests.\n\n**Location:** Harness `main.rs` (lines 148-151) vs Node `sync/historical/mod.rs` (lines 154-177).\n\n**The Problem:**\nWhen a peer first connects (`ActivePeerSession`), TCP windows are small, and the handshake might technically be finished, but the connection isn\u0027t \"stable\" yet.\n*   **Harness:** Waits `3s` before sending the first work batch.\n*   **Node:** Sends work immediately upon discovery.\n*   **Impact:** This often causes the first few requests to timeout or be throttled by the remote peer, leading to early failure penalties (bans) and a lower effective peer count during the start of the benchmark.\n\n### 3. Unnecessary Cloning in the Hot Path\n\nThe Node clones the entire Block Header (which includes 256 bytes of Bloom filters + extra data) just to calculate its hash. The Harness consumes the header (moves it).\n\n**Location:** `sync/historical/fetch.rs` (lines 35-37)\n\n```rust\n// Node\nif let Some(header) \u003d headers_by_number.remove(block) {\n    // You own \u0027header\u0027 here (removed from map), but you clone it!\n    let hash \u003d SealedHeader::seal_slow(header.clone()).hash(); \n    hashes.push((*block, hash));\n}\n```\n\n**The Problem:**\n`headers_by_number.remove` gives you ownership. `SealedHeader::seal_slow` takes ownership. The `.clone()` is a pure waste of CPU cycles and memory bandwidth. In a high-throughput scenario (1200 blocks/s), you are doing unnecessary `memcpy` operations 1200 times a second.\n\n**Fix:**\n```rust\nlet hash \u003d SealedHeader::seal_slow(header).hash(); // No clone\n```\n\n### 4. Stats Vector \"Memory Leak\"\n\nThe Harness clears its statistics vectors every reporting interval. The Node accumulates them **forever**.\n\n**Location:** `sync/historical/stats.rs` vs Harness `main.rs` (`WindowStats`).\n\n**The Problem:**\nIn `ProbeStats`, the `headers_ms`, `receipts_ms`, and `batch_ms` are `Vec\u003cu64\u003e`.\n```rust\npub fn record_timing(\u0026self, ...) {\n    if let Ok(mut values) \u003d self.headers_ms.lock() { values.push(headers_ms); }\n    // ...\n}\n```\nThese vectors are never cleared. They grow indefinitely.\n*   **Impact:** As the vectors grow, `push` eventually triggers reallocation (copying the whole vector to a new memory location). While amortized O(1), massive allocations under a Mutex lock interrupt the flow. In the Harness, `WindowStats` clears these vectors every few seconds.\n\n### 5. Sink Architecture vs. Direct Atomic Updates\n\nThe Harness workers update atomic counters directly. The Node workers create a `ProbeRecord` struct and send it over a channel to a Sink.\n\n**Location:** `sync/historical/mod.rs`\n\n**The Problem:**\n*   **Harness:** Worker -\u003e `AtomicU64::fetch_add` (Zero allocation, extremely fast).\n*   **Node:** Worker -\u003e Allocate `ProbeRecord` -\u003e Channel Send -\u003e Context Switch -\u003e Sink Read -\u003e Lock Mutex -\u003e Update.\n*   **Impact:** At 1200 blocks/s, this overhead is noticeable. Specifically, the channel `processed_blocks_tx` acts as a serialization point. If the `run_probe_sink` falls behind (e.g., waiting on those `stats` mutexes mentioned in point #4), it applies backpressure to *all* worker tasks, slowing down the P2P requests.\n\n### Summary Comparison Table\n\n| Feature | Harness (Fast) | Node (Slow) | Impact |\n| :--- | :--- | :--- | :--- |\n| **Task Management** | `tokio::spawn` (detached) | `JoinSet` (accumulates forever) | **High** (Resource leak) |\n| **P2P Warmup** | 3 Seconds | 0 Seconds | **Medium** (Early stability) |\n| **Header Hash** | Zero-copy (Move) | Clone | **Low/Medium** (CPU overhead) |\n| **Stats Memory** | Cleared every window | Accumulates forever | **Medium** (Reallocation pauses) |\n| **Stats Update** | Direct Atomic/Mutex | Channel -\u003e Sink -\u003e Mutex | **Medium** (Serialization bottleneck) |\n\n### Recommended Plan\n\n1.  **Fix the JoinSet:** In `sync/historical/mod.rs`, add `while fetch_tasks.try_join_next().is_some() {}` inside the loop.\n2.  **Remove the Clone:** In `sync/historical/fetch.rs`, remove `.clone()` when sealing the header.\n3.  **Restore Warmup:** In `sync/historical/mod.rs`, inside `spawn_peer_feeder`, add a short delay before sending the initial peers, or track connection time.\n4.  **Optimize Stats:** Change `ProbeStats` to use `AtomicU64` for counters and only store timing samples if explicitly requested (or use a circular buffer/window), rather than an infinitely growing vector.",
      "role": "model",
      "finishReason": "STOP",
      "tokenCount": 1652,
      "parts": [{
        "text": "This is a classic case of \"death by a thousand cuts\" where a clean, layered architecture introduces several small overheads that"
      }, {
        "text": " accumulate, along with a few specific implementation details that are functionally correct but performantly suboptimal compared to the raw \"harness"
      }, {
        "text": "\".\n\nHere is an analysis of the bottlenecks in the Node implementation compared to the Harness, ordered by impact.\n\n###"
      }, {
        "text": " 1. The \"JoinSet\" Leak (Major Resource/Runtime Overhead)\n\nIn the Harness, tasks are spawned using"
      }, {
        "text": " `tokio::spawn` and forgotten (detached). In the Node, you use a `JoinSet` but **"
      }, {
        "text": "you never poll it** inside the hot loop.\n\n**Location:** `sync/historical/mod.rs` ("
      }, {
        "text": "lines 130-134)\n\n```rust\n// Node: sync/historical/mod.rs\n"
      }, {
        "text": "let mut fetch_tasks: JoinSet\u003c()\u003e \u003d JoinSet::new();\nwhile let Some(peer) \u003d ready_"
      }, {
        "text": "rx.recv().await {\n    // ...\n    fetch_tasks.spawn(async move { ... });\n"
      }, {
        "text": "}\n// join_next is only called AFTER the loop finishes\n```\n\n**The Problem:**\nA `tok"
      }, {
        "text": "io::task::JoinSet` accumulates the results of finished tasks until you call `join_next()`. By not polling this"
      }, {
        "text": " inside the `while` loop, the Node accumulates a handle and a result for **every single batch processed** since the"
      }, {
        "text": " start of the run.\n*   **Impact:** Memory usage grows linearly. The runtime has to manage a massive list"
      }, {
        "text": " of finished task handles. This puts pressure on the allocator and the Tokio runtime scheduler.\n*   **Fix:** Poll the"
      }, {
        "text": " set inside the loop or switch to `tokio::spawn` if you don\u0027t need to track the tasks explicitly"
      }, {
        "text": " during the run.\n\n**Proposed Fix:**\n```rust\nwhile let Some(peer) \u003d ready_rx.recv()."
      }, {
        "text": "await {\n    // Clean up finished tasks to free memory/handles\n    while fetch_tasks.try_join_next"
      }, {
        "text": "().is_some() {} \n    \n    // ... existing logic ...\n    fetch_tasks.spawn(...)"
      }, {
        "text": "\n}\n```\n\n### 2. Lack of P2P Warmup (Networking Stability)\n\nThe Harness has a specific \""
      }, {
        "text": "Warmup\" period. The Node connects and immediately blasts peers with requests.\n\n**Location:** Harness `main.rs"
      }, {
        "text": "` (lines 148-151) vs Node `sync/historical/mod.rs` (lines 1"
      }, {
        "text": "54-177).\n\n**The Problem:**\nWhen a peer first connects (`ActivePeerSession`), TCP"
      }, {
        "text": " windows are small, and the handshake might technically be finished, but the connection isn\u0027t \"stable\" yet.\n"
      }, {
        "text": "*   **Harness:** Waits `3s` before sending the first work batch.\n*   **Node:** Sends"
      }, {
        "text": " work immediately upon discovery.\n*   **Impact:** This often causes the first few requests to timeout or be throttled by"
      }, {
        "text": " the remote peer, leading to early failure penalties (bans) and a lower effective peer count during the start of the benchmark."
      }, {
        "text": "\n\n### 3. Unnecessary Cloning in the Hot Path\n\nThe Node clones the entire Block Header (which includes "
      }, {
        "text": "256 bytes of Bloom filters + extra data) just to calculate its hash. The Harness consumes the header (moves"
      }, {
        "text": " it).\n\n**Location:** `sync/historical/fetch.rs` (lines 35-37)\n\n```rust"
      }, {
        "text": "\n// Node\nif let Some(header) \u003d headers_by_number.remove(block) {\n    //"
      }, {
        "text": " You own \u0027header\u0027 here (removed from map), but you clone it!\n    let hash \u003d SealedHeader::"
      }, {
        "text": "seal_slow(header.clone()).hash(); \n    hashes.push((*block, hash));\n}\n"
      }, {
        "text": "```\n\n**The Problem:**\n`headers_by_number.remove` gives you ownership. `SealedHeader"
      }, {
        "text": "::seal_slow` takes ownership. The `.clone()` is a pure waste of CPU cycles and memory bandwidth. In"
      }, {
        "text": " a high-throughput scenario (1200 blocks/s), you are doing unnecessary `memcpy` operations 1"
      }, {
        "text": "200 times a second.\n\n**Fix:**\n```rust\nlet hash \u003d SealedHeader::seal_slow(header"
      }, {
        "text": ").hash(); // No clone\n```\n\n### 4. Stats Vector \"Memory Leak\"\n\nThe Harness clears its statistics"
      }, {
        "text": " vectors every reporting interval. The Node accumulates them **forever**.\n\n**Location:** `sync/historical/stats.rs` vs"
      }, {
        "text": " Harness `main.rs` (`WindowStats`).\n\n**The Problem:**\nIn `ProbeStats`, the `headers_ms`,"
      }, {
        "text": " `receipts_ms`, and `batch_ms` are `Vec\u003cu64\u003e`.\n```rust\npub"
      }, {
        "text": " fn record_timing(\u0026self, ...) {\n    if let Ok(mut values) \u003d self.headers_ms"
      }, {
        "text": ".lock() { values.push(headers_ms); }\n    // ...\n}\n```\nThese vectors are never"
      }, {
        "text": " cleared. They grow indefinitely.\n*   **Impact:** As the vectors grow, `push` eventually triggers reallocation (copy"
      }, {
        "text": "ing the whole vector to a new memory location). While amortized O(1), massive allocations under a Mutex lock"
      }, {
        "text": " interrupt the flow. In the Harness, `WindowStats` clears these vectors every few seconds.\n\n### 5. Sink"
      }, {
        "text": " Architecture vs. Direct Atomic Updates\n\nThe Harness workers update atomic counters directly. The Node workers create a `ProbeRecord` struct and send"
      }, {
        "text": " it over a channel to a Sink.\n\n**Location:** `sync/historical/mod.rs`\n\n**The Problem:**"
      }, {
        "text": "\n*   **Harness:** Worker -\u003e `AtomicU64::fetch_add` (Zero allocation, extremely fast)."
      }, {
        "text": "\n*   **Node:** Worker -\u003e Allocate `ProbeRecord` -\u003e Channel Send -\u003e Context Switch -\u003e Sink Read -\u003e Lock"
      }, {
        "text": " Mutex -\u003e Update.\n*   **Impact:** At 1200 blocks/s, this overhead is noticeable. Specifically"
      }, {
        "text": ", the channel `processed_blocks_tx` acts as a serialization point. If the `run_probe_sink"
      }, {
        "text": "` falls behind (e.g., waiting on those `stats` mutexes mentioned in point #4), it applies backpressure to *"
      }, {
        "text": "all* worker tasks, slowing down the P2P requests.\n\n### Summary Comparison Table\n\n| Feature | Harness (Fast)"
      }, {
        "text": " | Node (Slow) | Impact |\n| :--- | :--- | :--- | :--- |\n| **Task Management"
      }, {
        "text": "** | `tokio::spawn` (detached) | `JoinSet` (accumulates forever) | **High"
      }, {
        "text": "** (Resource leak) |\n| **P2P Warmup** | 3 Seconds | 0 Seconds | **Medium**"
      }, {
        "text": " (Early stability) |\n| **Header Hash** | Zero-copy (Move) | Clone | **Low/"
      }, {
        "text": "Medium** (CPU overhead) |\n| **Stats Memory** | Cleared every window | Accumulates forever | **"
      }, {
        "text": "Medium** (Reallocation pauses) |\n| **Stats Update** | Direct Atomic/Mutex | Channel -\u003e Sink -\u003e Mutex"
      }, {
        "text": " | **Medium** (Serialization bottleneck) |\n\n### Recommended Plan\n\n1.  **Fix the JoinSet:** In"
      }, {
        "text": " `sync/historical/mod.rs`, add `while fetch_tasks.try_join_next().is_some()"
      }, {
        "text": " {}` inside the loop.\n2.  **Remove the Clone:** In `sync/historical/fetch.rs`,"
      }, {
        "text": " remove `.clone()` when sealing the header.\n3.  **Restore Warmup:** In `sync/historical/mod."
      }, {
        "text": "rs`, inside `spawn_peer_feeder`, add a short delay before sending the initial peers, or track connection time"
      }, {
        "text": ".\n4.  **Optimize Stats:** Change `ProbeStats` to use `AtomicU64` for counters and"
      }, {
        "text": " only store timing samples if explicitly requested (or use a circular buffer/window), rather than an infinitely growing vector."
      }, {
        "text": "",
        "thoughtSignature": "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"
      }]
    }],
    "pendingInputs": [{
      "text": "",
      "role": "user"
    }]
  }
}