# Ethereum L1: “Stateless” History Clients and Existing Efforts

**Prior Discussions:** The idea of a lightweight client that indexes event logs without maintaining full state has been contemplated in Ethereum research. In fact, Ethereum developers predicted that **stateless clients would benefit use cases like log/event watchers** – users who want to follow contract events but don’t need arbitrary state queries[\[1\]](https://ethresear.ch/t/kittenless-a-concrete-proposal-for-stateless-ethereum/7047#:~:text=I%20wonder%20who%20would%20use,a%20call%20under%20the%20hood). In a 2020 “Kittenless” proposal (a plan for stateless Ethereum), it was noted that a dApp developer interested *only* in events could run a node that *just syncs headers and block data*, without a full state DB[\[2\]](https://ethresear.ch/t/kittenless-a-concrete-proposal-for-stateless-ethereum/7047#:~:text=These%20two%20were%20exactly%20what,I%20had%20in%20mind). This would let them start/stop and even fail over nodes cheaply, since they’d only need to download the canonical headers and relevant receipts. In short, the concept of a **stateless event-indexing node** *has* been discussed in theory, and Ethereum’s roadmap for statelessness has kept this use-case in mind[\[2\]](https://ethresear.ch/t/kittenless-a-concrete-proposal-for-stateless-ethereum/7047#:~:text=These%20two%20were%20exactly%20what,I%20had%20in%20mind).

**Existing Implementations on L1:** Only recently have concrete implementations emerged. One is the **Portal Network**, which is an Ethereum project to serve historical data (headers, transactions, receipts) over a distributed network of lightweight “portal” nodes[\[3\]](https://ethereum-magicians.org/t/eip-7719-p2p-history-network/20231#:~:text=Execution%20chain%20history%20data%20consists,and%20block%20receipts). Portal clients like Trin (Rust) and Fluffy (Nimbus/Nim) form a DHT-based overlay that stores shards of historical chain data and responds to requests for things like old block receipts[\[4\]](https://ethereum-magicians.org/t/eip-7719-p2p-history-network/20231#:~:text=The%20chain%20history%20network%20is,wire.md%29%20protocol)[\[5\]](https://blog.nimbus.team/nimbus-portal-client-entering-a-portable-and-decentralised-ethereum/#:~:text=,as%20a%20distributed%20archival%20node). This network is **designed for stateless or light clients** – you can run a portal client with minimal storage (even tens of MB) and fetch *only* the data you need (e.g. receipts for certain blocks) on demand[\[6\]](https://ethereum.github.io/trin/concepts/portal_vs_standard.html#:~:text=The%20amount%20you%20store%20is,10%20MB%2C%20if%20you%20want)[\[7\]](https://ethereum.github.io/trin/concepts/portal_vs_standard.html#:~:text=Standard%20JSON). The trade-off is higher latency (lots of network lookups) and a “partial view” of data, but in return the client is extremely lightweight[\[8\]](https://ethereum.github.io/trin/concepts/portal_vs_standard.html#:~:text=There%20are%20some%20drawbacks%20to,Here%20are%20some%20known%20ones)[\[9\]](https://ethereum.github.io/trin/concepts/portal_vs_standard.html#:~:text=The%20essense%20of%20Portal%20is,slice%20of%20the%20total%20data). The Portal Network’s history subprotocol was formalized in draft EIP-7719, which explicitly covers distributing **block headers, bodies, and receipts** via a Kademlia DHT[\[3\]](https://ethereum-magicians.org/t/eip-7719-p2p-history-network/20231#:~:text=Execution%20chain%20history%20data%20consists,and%20block%20receipts). In other words, Portal is *exactly* a solution for stateless history access on L1 – albeit using a new overlay network rather than the legacy devp2p gossip.

Another recent effort is **Ress (Reth Stateless)** by Paradigm (2025), which takes a different approach. Ress is essentially a modified Ethereum client (based on Reth in Rust) that can **fully validate blocks without a local state DB**[\[10\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=We%20are%20excited%20to%20announce,L2%20ecosystem%E2%80%99s%20security%20%26%20interoperability). It requests all needed state data (“witnesses” proving account/storage contents) from peers and then executes transactions in-memory to verify blocks[\[11\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=%E2%80%9CStateless%E2%80%9D%20means%20a%20node%20does,all%20transactions%20in%20that%20block)[\[12\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=Ress%20is%20built%20using%20Reth,to%20stateless%20Ethereum%20peers). Ress nodes only store minimal data long-term (on the order of \~14 GB for contracts’ bytecode, versus \~1+ TB for a full archive node)[\[13\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=We%20are%20excited%20to%20announce,L2%20ecosystem%E2%80%99s%20security%20%26%20interoperability). This is a **stateless full node** rather than a pure log indexer – it still runs the EVM for each block (with supplied witnesses) to check correctness – but it proves that one can participate in the network *without* maintaining the full state. Notably, the Ress team implemented a custom RLPx subprotocol so that stateful peers (normal nodes) can supply it with the required state chunks, block bodies, and bytecodes on the fly[\[12\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=Ress%20is%20built%20using%20Reth,to%20stateless%20Ethereum%20peers). This is similar in spirit to what you propose (fetching just the necessary data via p2p), though Ress goes further by actually verifying state roots and executing every transaction. It’s also **extendable to L2** in concept: the authors note that stateless clients could help scale optimistic rollups by letting many verifiers each re-execute portions of L2 blocks without storing full state[\[14\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=larger%20the%20state,secure%2Finteroperable%20rollups%20that%20tightly%20integrate).

**Older Light-Client Protocols:** It’s worth mentioning that Ethereum *did* have a Light Ethereum Subprotocol (LES) in earlier years, which allowed light nodes to request data (headers, proofs, and yes, receipts) from full nodes. In fact, the devp2p protocol definition includes a GetReceipts message for retrieving receipts by block hash[\[15\]](https://github.com/ethereum/devp2p/blob/master/caps/les.md#:~:text=Require%20peer%20to%20return%20a,of%20receipts%20which%20correspond). So, in principle, a light client could ask a full node for transaction receipts of a given block, and the full node would return those receipts. **Why didn’t this solve your problem?** In practice, LES had a very limited adoption – it required full nodes to run a “LES server” mode, which many didn’t (it consumes resources without benefit to the server operator). By 2020, it became clear that LES was not scaling; few nodes were serving, and those that did could be overloaded. This is one reason the Portal Network was conceived: to replace the client-server model with a decentralized DHT approach, making it more robust for many light clients to fetch history. In short, Ethereum’s native p2p *does* support fetching receipts (and during fast-sync, clients themselves download headers/bodies and can download receipts if needed), but **after** the adoption of **EIP-4444** (history pruning) this is no longer reliable for older data. Modern execution clients (Geth, etc.) will simply **stop serving block bodies and receipts older than a certain cutoff (e.g. one year)**[\[16\]](https://hackmd.io/@advaita/BkMvD9Qllg#:~:text=%5BEIP,weeks)[\[17\]](https://blog.nimbus.team/nimbus-portal-client-entering-a-portable-and-decentralised-ethereum/#:~:text=The%20implementation%20plan%20for%20EIP,this%20data%20from%20their%20clients). This was done to cap storage bloat. So, a stateless indexer that tries to fetch *very old* receipts via the legacy p2p might find that most peers refuse – the data has been pruned. The Portal Network and community-maintained snapshots (like .era1 history files[\[18\]](https://hackmd.io/@advaita/BkMvD9Qllg#:~:text=format%20is%20the%20,Auditing%20and%20reprocessing%20historical)) are the intended solution for obtaining historical receipts going forward.

**Why Hasn’t a P2P “Receipts-Only” Client Been Common?** There are several reasons, discussed in the community, why we haven’t seen a widely-used tool for this before:

* **Network Load Concerns:** Pulling *every* log or receipt via p2p can put significant strain on full nodes. Ethereum developer Nick Johnson pointed out that if many clients did their own filtering by downloading all logs, it would *“impose a lot of unnecessary load on nodes”*[\[19\]](https://ethereum-magicians.org/t/towards-a-stateless-node-api/1458#:~:text=Nodes%20are%20able%20to%20filter,that%20wants%20to%20understand%20logs). Full nodes are optimized to internally scan and filter logs (e.g. via bloom filters or indexed DBs); having potentially thousands of stateless clients each ask peers for entire blocks’ receipts and then filter them client-side is inefficient and could be abusive. In 2018, Infura and others actually disabled the older eth\_newFilter log streaming API partly because it was stateful and heavy – and the stateless alternative (eth\_getLogs polling) still puts load on nodes if misused. In short, there’s been a **hesitancy to encourage lots of “parasitic” light clients** that download tons of data but don’t share anything. Ethereum’s answer to this is to either use *centralized services* (e.g. Infura, The Graph) which run the heavy nodes, or to develop the Portal network where light nodes contribute resources in a DHT. Your idea is perfectly logical for a single user, but if everyone built their own stateless indexer, the network could suffer without a coordinated solution like Portal. This concern has been echoed in forum discussions[\[19\]](https://ethereum-magicians.org/t/towards-a-stateless-node-api/1458#:~:text=Nodes%20are%20able%20to%20filter,that%20wants%20to%20understand%20logs).

* **Historical Availability:** As mentioned, after EIP-4444, running a history indexer purely via *ad hoc* requests on the L1 p2p network is getting harder. Peers simply won’t serve data older than the prune window (many clients now drop anything older than 1 year, and an even stricter “history expiry” may be coming)[\[16\]](https://hackmd.io/@advaita/BkMvD9Qllg#:~:text=%5BEIP,weeks)[\[17\]](https://blog.nimbus.team/nimbus-portal-client-entering-a-portable-and-decentralised-ethereum/#:~:text=The%20implementation%20plan%20for%20EIP,this%20data%20from%20their%20clients). That means a naive stateless client might succeed for recent blocks but would **hit a wall for older events** unless it finds archive nodes. The Ethereum community anticipated this and invested in out-of-band solutions (Portal, archival snapshots, etc.) rather than encouraging individual developers to scrape data from random full nodes. In other words, it *“seems obvious”* to build such a client, but the protocol evolution (pruning old data) actively forces a more structured approach.

* **Engineering Effort and Trust Trade-offs:** Implementing a custom devp2p client that maintains the chain of headers, requests receipts, and verifies Merkle proofs (to ensure receipts match the header’s receiptsRoot) is non-trivial. It’s easier today than a few years ago (projects like **trin** and **ultralight** provide libraries for the portal protocols, and clients like **Reth** provide reusable networking stacks), but it’s still a significant project. In the past, most teams with this need (e.g. blockchain explorers or indexers) took a simpler route: run a full or archive node and query it, or use an RPC provider. There wasn’t a strong incentive to invest developer time into a bespoke stateless indexer when the “problem” could be solved with money (paying for infrastructure or third-party RPC). Only now, with the push for decentralization of infrastructure and lower resource nodes, has this become a hot topic again. Even so, **the first stateless clients are just now coming online** (Portal clients in 2023–2025, Ress in 2025), so the ecosystem is playing catch-up. Additionally, a stateless client that doesn’t execute transactions must **trust that the data from peers is correct** (at least up to checking the receipts root against the header). This weaker security model was acceptable only to niche users historically; most Ethereum node implementations prioritized fully verifying everything. Your “stage-1 pragmatic” trust model is reasonable (and others are now adopting it), but hardcore Ethereum folks in earlier years were often uncomfortable with anything less than full verification, which might be another reason it “hasn’t been done” widely before. Now that we have PoS finality and better fraud detection, trusting headers and receipt roots from a peer set is seen as an acceptable trade-off by more people.

**Summary of L1:** Yes, the idea of a stateless Uniswap events indexer has been floated in various forms. **Portal Network** is the closest official solution – it will let you fetch headers and receipts without a full node[\[3\]](https://ethereum-magicians.org/t/eip-7719-p2p-history-network/20231#:~:text=Execution%20chain%20history%20data%20consists,and%20block%20receipts) – although it uses a DHT overlay (which you noted you’d prefer to avoid). And **Ress/Reth** shows that even execution can be done statelessly with cooperation from peers[\[12\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=Ress%20is%20built%20using%20Reth,to%20stateless%20Ethereum%20peers). So you’re definitely *not* the first to think of this; it’s an “obvious” idea that required a lot of groundwork to become practical. The general sentiment is that it’s **hard but feasible** – and only now becoming reality with new protocols. If you want to stick to the standard devp2p (eth66+) network without the Portal DHT, you might actually be reimplementing some of LES or Ress’s functionality (i.e. requesting receipts by block hash from peers). That can work for recent history (and indeed geth’s fast sync uses similar techniques internally), but for completeness you’ll eventually lean on Portal or an archive for older data due to pruning[\[16\]](https://hackmd.io/@advaita/BkMvD9Qllg#:~:text=%5BEIP,weeks).

# L2 Optimistic Rollups (Optimism/Base vs Arbitrum)

Building a stateless history client for Optimism/Base (OP Stack chains) is more challenging, and as of now there aren’t known public implementations of it. The OP Stack chains *do* use an execution client (op-geth or op-reth) that is quite similar to Ethereum’s, and post-Bedrock they reintroduced a P2P networking layer for the rollup nodes[\[20\]](https://specs.optimism.io/protocol/rollup-node-p2p.html#:~:text=Rollup%20Node%20P2P%20,the%20rest%20of%20the%20network). In theory, this means an Optimism full node can peer with others and exchange new blocks/transactions over libp2p (to reduce latency versus relying solely on L1). However, **historical data on L2 is fundamentally anchored in L1**: Optimism (and Base) compress their transaction batches and post them to Ethereum L1 (e.g. in calldata of L1 transactions), and regularly post state root commitments. To fully reconstruct L2 blocks and receipts, a node either ingests the L1 data and runs an “op-node” (rollup node \+ execution client) to execute it, or fetches the already-executed results from somewhere. Unlike Ethereum L1, there’s *no widely-deployed distributed network of L2 archival data*. The Optimism team has indicated that with the new architecture, eventually even peer-to-peer syncing of L2 blocks could be possible, but **as of Bedrock, a new node still needs an L1 connection to get the history** (batches of transactions) and then must execute them. In fact, before Bedrock, Optimism nodes had **no P2P at all** – you *had* to sync from L1 and the central sequencer. A 2022 GitHub issue confirmed *“no L2 p2p network. This will change with Bedrock where P2P will be reintroduced.”*[\[21\]](https://github.com/ethereum-optimism/optimism/issues/2605#:~:text=How%20do%20I%20run%20just,At%20the). Now that P2P exists, third-party full nodes can share *recent* L2 blocks among each other, but the **canonical source of truth is still the data posted on L1**.

What does that mean for a stateless indexer? It means that, for Optimism, you could attempt something analogous to your L1 approach – peer with op-geth nodes and try to fetch block headers and receipts. But in practice, Optimism nodes don’t have an incentive to serve old receipts to random peers, and the protocol for it is not standardized like Ethereum’s (it’s possible op-geth inherited the receipt-serving capability from geth, but this isn’t well-documented publicly). More importantly, **to trust L2 data you might need to validate it against L1**. An Optimism block’s authenticity comes from the L1 batch data and the absence of a fraud proof during the challenge window. A stateless client could choose to *trust* that the sequencer’s outputs are correct and just index the logs, but that introduces a trust assumption on the sequencer (until finalization). Many users instead run a full node to independently verify the L2 state roots. In your “stage-1” pragmatic approach, you might accept trusting the L2 receipts as long as they correspond to an L1-posted block hash or output root. That’s doable, but again it’s a niche trade-off that few have implemented so far.

As for **Arbitrum (Nitro)**, the situation is even more stark: Arbitrum doesn’t use peer-to-peer gossip for its execution layer at all. According to Offchain Labs’ docs, *“Arbitrum doesn’t have a consensus mechanism, so ‘p2p mode’ doesn’t apply. To sync, nodes read batches from L1 and connect to the Sequencer feed… In no case do nodes need to peer up and sync with each other.”*[\[22\]](https://docs.arbitrum.io/node-running/faq#:~:text=Can%20I%20run%20an%20Arbitrum,node%20in%20p2p%20mode). Every Arbitrum full node basically follows the L1 contract’s data and the Sequencer’s feed; there’s no concept of one Arbitrum node asking another for a block or receipt. This means you **cannot** build an Arbitrum log indexer by simply querying peer nodes – the network won’t give you anything because each node expects you to get it from L1. In essence, to get Arbitrum receipts, you must run an Arbitrum node (or use a provider that did). A “stateless” Arbitrum client would essentially involve re-implementing Arbitrum’s execution engine to process the L1 calldata and produce receipts, but maybe without storing the full state. That’s theoretically possible (similar to how Ress doesn’t store all state), but as of today no such alternative implementation exists publicly. Arbitrum’s node software is quite complex (it includes fraud-proof machinery, BLS signatures for the Sequencer feed, etc.), so writing a stateless variant would be a significant project on its own. The Arbitrum team hasn’t released a stateless mode for Nitro, and community efforts have focused more on ensuring one can run full nodes (with hefty hardware, since Arbitrum’s state grows large) or using their JSON-RPC for data.

**Bottom line for L2:** You’re not missing an existing solution – *this is largely uncharted territory.* Optimism/Base could in the future leverage something like Portal or Ress-style stateless execution, especially since the codebase is similar to Ethereum’s (for example, the Reth team’s work hints at stateless verification being usable for L2 as well[\[14\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=larger%20the%20state,secure%2Finteroperable%20rollups%20that%20tightly%20integrate)). But at present, anyone indexing L2 events typically runs a full node or uses an RPC service. There has been *discussion* in broad terms (e.g., “could we have stateless rollup nodes that only verify fraud proofs or subsets of state?”), and indeed the Ress announcement explicitly mentioned **stateless L2 verifier nodes** as a way to scale optimistic rollups[\[14\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=larger%20the%20state,secure%2Finteroperable%20rollups%20that%20tightly%20integrate). That implies people are thinking about it, but no turnkey implementation is out yet. Your observation about Arbitrum is correct: without P2P data exchange, a stateless Arbitrum indexer would need to pull all data from L1 (which includes only transactions, not the resulting logs) and then execute them in a custom stateless manner – essentially as hard as writing a new Arbitrum client. So focusing on OP Stack first (which at least has some P2P and open-source execution clients) is wise.

**Why hasn’t anyone built a stateless OP/Arbitrum indexer?** Probably because until recently, even the *normal* full nodes for these networks were under active development and changing (Optimism’s Bedrock upgrade was mid-2023, Arbitrum Nitro in 2022). The teams themselves prioritize robust full nodes and haven’t provided light clients. There’s also a smaller community of node operators on these L2s, so a third-party developer might not invest in a stateless client without clear demand. Additionally, the trust model on L2s is tricky: a stateless L2 client might be “weaker” security unless it verifies proofs, and if you’re going that far, you may as well run the full node. It’s a kind of catch-22: the simplest safe way to get L2 logs is just run the official node software (which does require state). This is likely why **no one has publicly released a tool like you describe for Optimism or Arbitrum yet.**

### **Conclusion**

In summary, your idea of a stateless history client for indexing (especially for Uniswap v4 events) **has been discussed and is gradually becoming reality on L1**, but it’s a bleeding-edge area. Ethereum L1 has solutions like the Portal Network (history subprotocol) for fetching headers and receipts without a full node[\[3\]](https://ethereum-magicians.org/t/eip-7719-p2p-history-network/20231#:~:text=Execution%20chain%20history%20data%20consists,and%20block%20receipts), and projects like Ress that prove stateless execution is possible[\[12\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=Ress%20is%20built%20using%20Reth,to%20stateless%20Ethereum%20peers). The concept was anticipated years ago in Ethereum’s stateless roadmaps[\[1\]](https://ethresear.ch/t/kittenless-a-concrete-proposal-for-stateless-ethereum/7047#:~:text=I%20wonder%20who%20would%20use,a%20call%20under%20the%20hood), but it hadn’t been implemented due to the challenges noted (network load, lack of urgency, complexity). On L2s, there’s even less existing work – Arbitrum outright lacks p2p sync[\[22\]](https://docs.arbitrum.io/node-running/faq#:~:text=Can%20I%20run%20an%20Arbitrum,node%20in%20p2p%20mode), and Optimism’s new p2p is not yet leveraged for “light client” purposes. So you might indeed be among the first pushing on a stateless L2 indexer idea publicly. The arguments against it historically were mainly **practicality and impact on others**: it was seen as too hard to do without protocol changes, and potentially harmful if done in ad hoc ways (many scraping nodes hammering full nodes)[\[19\]](https://ethereum-magicians.org/t/towards-a-stateless-node-api/1458#:~:text=Nodes%20are%20able%20to%20filter,that%20wants%20to%20understand%20logs). Now that those protocol changes (e.g. Portal, stateless witnesses) are in motion, we’re likely to see more “stateless client” use-cases flourish. Your plan aligns with the general direction Ethereum is headed – just be aware that for L1 you’ll likely end up interacting with the Portal Network or trusted archival sources for old blocks, and for L2 you may have to accept using your own L1 node and a slightly stateful rollup node unless/until the ecosystem catches up.

**Sources:**

* Ethereum Magicians forum – *“Towards a stateless node API”* (Nick Johnson’s comments on log fetching load)[\[19\]](https://ethereum-magicians.org/t/towards-a-stateless-node-api/1458#:~:text=Nodes%20are%20able%20to%20filter,that%20wants%20to%20understand%20logs).

* Ethereum Research forum – *“Kittenless stateless Ethereum”* (discussion of stateless clients for event logs)[\[1\]](https://ethresear.ch/t/kittenless-a-concrete-proposal-for-stateless-ethereum/7047#:~:text=I%20wonder%20who%20would%20use,a%20call%20under%20the%20hood)[\[2\]](https://ethresear.ch/t/kittenless-a-concrete-proposal-for-stateless-ethereum/7047#:~:text=These%20two%20were%20exactly%20what,I%20had%20in%20mind).

* Paradigm’s Ress announcement – (stateless Ethereum Execution Layer, custom p2p for witnesses)[\[13\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=We%20are%20excited%20to%20announce,L2%20ecosystem%E2%80%99s%20security%20%26%20interoperability)[\[12\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=Ress%20is%20built%20using%20Reth,to%20stateless%20Ethereum%20peers).

* Ethereum Portal Network spec (History network for headers/bodies/receipts via DHT)[\[3\]](https://ethereum-magicians.org/t/eip-7719-p2p-history-network/20231#:~:text=Execution%20chain%20history%20data%20consists,and%20block%20receipts); Nimbus team blog on Portal and EIP-4444 (dropping old receipts from p2p)[\[17\]](https://blog.nimbus.team/nimbus-portal-client-entering-a-portable-and-decentralised-ethereum/#:~:text=The%20implementation%20plan%20for%20EIP,this%20data%20from%20their%20clients).

* Arbitrum developer FAQ – (no p2p sync in Arbitrum; nodes must read from L1/Sequencer)[\[22\]](https://docs.arbitrum.io/node-running/faq#:~:text=Can%20I%20run%20an%20Arbitrum,node%20in%20p2p%20mode).

* Optimism Bedrock notes – (reintroduction of p2p network for rollup nodes)[\[20\]](https://specs.optimism.io/protocol/rollup-node-p2p.html#:~:text=Rollup%20Node%20P2P%20,the%20rest%20of%20the%20network).

---

[\[1\]](https://ethresear.ch/t/kittenless-a-concrete-proposal-for-stateless-ethereum/7047#:~:text=I%20wonder%20who%20would%20use,a%20call%20under%20the%20hood) [\[2\]](https://ethresear.ch/t/kittenless-a-concrete-proposal-for-stateless-ethereum/7047#:~:text=These%20two%20were%20exactly%20what,I%20had%20in%20mind) Kittenless: A concrete proposal for stateless ethereum \- Execution Layer Research \- Ethereum Research

[https://ethresear.ch/t/kittenless-a-concrete-proposal-for-stateless-ethereum/7047](https://ethresear.ch/t/kittenless-a-concrete-proposal-for-stateless-ethereum/7047)

[\[3\]](https://ethereum-magicians.org/t/eip-7719-p2p-history-network/20231#:~:text=Execution%20chain%20history%20data%20consists,and%20block%20receipts) [\[4\]](https://ethereum-magicians.org/t/eip-7719-p2p-history-network/20231#:~:text=The%20chain%20history%20network%20is,wire.md%29%20protocol) EIP-7719: P2P History Network \- EIPs \- Fellowship of Ethereum Magicians

[https://ethereum-magicians.org/t/eip-7719-p2p-history-network/20231](https://ethereum-magicians.org/t/eip-7719-p2p-history-network/20231)

[\[5\]](https://blog.nimbus.team/nimbus-portal-client-entering-a-portable-and-decentralised-ethereum/#:~:text=,as%20a%20distributed%20archival%20node) [\[17\]](https://blog.nimbus.team/nimbus-portal-client-entering-a-portable-and-decentralised-ethereum/#:~:text=The%20implementation%20plan%20for%20EIP,this%20data%20from%20their%20clients) Nimbus Portal Client: Entering a Portable and Decentralised Ethereum

[https://blog.nimbus.team/nimbus-portal-client-entering-a-portable-and-decentralised-ethereum/](https://blog.nimbus.team/nimbus-portal-client-entering-a-portable-and-decentralised-ethereum/)

[\[6\]](https://ethereum.github.io/trin/concepts/portal_vs_standard.html#:~:text=The%20amount%20you%20store%20is,10%20MB%2C%20if%20you%20want) [\[7\]](https://ethereum.github.io/trin/concepts/portal_vs_standard.html#:~:text=Standard%20JSON) [\[8\]](https://ethereum.github.io/trin/concepts/portal_vs_standard.html#:~:text=There%20are%20some%20drawbacks%20to,Here%20are%20some%20known%20ones) [\[9\]](https://ethereum.github.io/trin/concepts/portal_vs_standard.html#:~:text=The%20essense%20of%20Portal%20is,slice%20of%20the%20total%20data) Portal vs Standard Clients \- Trin

[https://ethereum.github.io/trin/concepts/portal\_vs\_standard.html](https://ethereum.github.io/trin/concepts/portal_vs_standard.html)

[\[10\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=We%20are%20excited%20to%20announce,L2%20ecosystem%E2%80%99s%20security%20%26%20interoperability) [\[11\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=%E2%80%9CStateless%E2%80%9D%20means%20a%20node%20does,all%20transactions%20in%20that%20block) [\[12\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=Ress%20is%20built%20using%20Reth,to%20stateless%20Ethereum%20peers) [\[13\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=We%20are%20excited%20to%20announce,L2%20ecosystem%E2%80%99s%20security%20%26%20interoperability) [\[14\]](https://www.paradigm.xyz/2025/03/stateless-reth-nodes#:~:text=larger%20the%20state,secure%2Finteroperable%20rollups%20that%20tightly%20integrate) Ress: Scaling Ethereum with Stateless Reth Nodes

[https://www.paradigm.xyz/2025/03/stateless-reth-nodes](https://www.paradigm.xyz/2025/03/stateless-reth-nodes)

[\[15\]](https://github.com/ethereum/devp2p/blob/master/caps/les.md#:~:text=Require%20peer%20to%20return%20a,of%20receipts%20which%20correspond) Light Ethereum Subprotocol (LES) \- devp2p \- GitHub

[https://github.com/ethereum/devp2p/blob/master/caps/les.md](https://github.com/ethereum/devp2p/blob/master/caps/les.md)

[\[16\]](https://hackmd.io/@advaita/BkMvD9Qllg#:~:text=%5BEIP,weeks) [\[18\]](https://hackmd.io/@advaita/BkMvD9Qllg#:~:text=format%20is%20the%20,Auditing%20and%20reprocessing%20historical)  Downloading Ethereum History with a Parallel Downloader for era1, era files \- HackMD

[https://hackmd.io/@advaita/BkMvD9Qllg](https://hackmd.io/@advaita/BkMvD9Qllg)

[\[19\]](https://ethereum-magicians.org/t/towards-a-stateless-node-api/1458#:~:text=Nodes%20are%20able%20to%20filter,that%20wants%20to%20understand%20logs) Towards a stateless node API \- Ethereum Architects \- Fellowship of Ethereum Magicians

[https://ethereum-magicians.org/t/towards-a-stateless-node-api/1458](https://ethereum-magicians.org/t/towards-a-stateless-node-api/1458)

[\[20\]](https://specs.optimism.io/protocol/rollup-node-p2p.html#:~:text=Rollup%20Node%20P2P%20,the%20rest%20of%20the%20network) Rollup Node P2P \- OP Stack Specification \- Optimism Specs

[https://specs.optimism.io/protocol/rollup-node-p2p.html](https://specs.optimism.io/protocol/rollup-node-p2p.html)

[\[21\]](https://github.com/ethereum-optimism/optimism/issues/2605#:~:text=How%20do%20I%20run%20just,At%20the) How do I run just a L2 full node for RPC access? \#2605 \- GitHub

[https://github.com/ethereum-optimism/optimism/issues/2605](https://github.com/ethereum-optimism/optimism/issues/2605)

[\[22\]](https://docs.arbitrum.io/node-running/faq#:~:text=Can%20I%20run%20an%20Arbitrum,node%20in%20p2p%20mode) Frequently asked questions: Run a node | Arbitrum Docs

[https://docs.arbitrum.io/node-running/faq](https://docs.arbitrum.io/node-running/faq)